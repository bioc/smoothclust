% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smoothclust.R
\name{smoothclust}
\alias{smoothclust}
\title{smoothclust}
\usage{
smoothclust(
  input,
  method = c("uniform", "kernel", "knn"),
  assay_name = "counts",
  bandwidth = 0.05,
  truncate = 0.05,
  k = 6,
  keep_unsmoothed = TRUE
)
}
\arguments{
\item{input}{Input data, assumed to be provided as \code{SpatialExperiment}
object containing spatial coordinates in \code{spatialCoords} slot and
expression counts in \code{assay} slots.}

\item{method}{Method used for smoothing. The \code{uniform} method calculates
unweighted averages across spatial locations within a circular window with
radius \code{bandwidth} at each spatial location, which smooths out spatial
variability as well as sparsity due to sampling variability. The
\code{kernel} method calculates a weighted average using a truncated
exponential kernel applied to Euclidean distances with a length scale
parameter equal to \code{bandwidth}, which provides a more sophisticated
approach to smoothing out spatial variability but may be affected by
sparsity due to sampling variability (especially sparsity at the index
point), and is computationally slower. The \code{knn} method calculates an
average across the index point and k nearest neighbors. Default =
\code{uniform}.}

\item{assay_name}{Name of \code{assay} in input object containing expression
count values to be smoothed. In most cases, this will be \code{counts},
containing raw expression counts. Alternatively, \code{logcounts} or any
other assay may also be used. If \code{logcounts} are used, the smoothed
values represent geometric averages, which are more difficult to interpret.
We recommend using raw counts (\code{counts}) for easier interpretation of
the averages. Default = \code{counts}.}

\item{bandwidth}{Bandwidth parameter for smoothing, expressed as proportion
of width or height (whichever is greater) of tissue area. Smoothing is
performed across neighboring values at each point. For \code{method =
"uniform"}, the bandwidth represents the radius of a circle, and unweighted
averages are calculated across points within this circle. For \code{method
= "kernel"}, the averaging is weighted by distances scaled using a
truncated exponential kernel applied to Euclidean distances. For example, a
bandwidth of 0.05 will smooth values across neighbors weighted by distances
scaled using a truncated exponential kernel with length scale equal to 5%
of the width or height (whichever is greater) of the tissue area. Weights
for \code{method = "kernel"} are truncated at small values for
computational efficiency. Default = 0.05.}

\item{truncate}{Truncation threshold parameter if \code{method = "kernel"}.
Kernel weights below this value are set to zero for computational
efficiency. Only used for \code{method = "kernel"}. Default = 0.05.}

\item{k}{Number of nearest neighbors for \code{method = "knn"}. Only used for
\code{method == "knn"}. Default = 6 (based on honeycomb pattern for 10x
Genomics Visium platform).}

\item{keep_unsmoothed}{Whether to keep unsmoothed expression values in a
separate \code{assay}. If TRUE, these will be stored in an \code{assay}
named \code{<assay_name>_unsmoothed} (e.g. \code{counts_unsmoothed}).}
}
\value{
Returns the \code{SpatialExperiment} object with spatially smoothed
  smoothed expression values stored in the \code{assay} named
  \code{assay_name} (e.g. \code{counts}), which can then be used as the input
  for further downstream analyses such as clustering.
}
\description{
Spatial clustering algorithm for spatial transcriptomics data.
}
\details{
Spatial clustering algorithm for spatial transcriptomics data based on the
principle of smoothing expression measurements across neighboring spatial
locations. The algorithm can be used to define spatial domains consisting of
a single cell type or a consistent mixture of cell types with smooth spatial
boundaries.
}
\examples{
library(STexampleData)

# load data
spe <- Visium_humanDLPFC()

# keep spots over tissue
spe <- spe[, colData(spe)$in_tissue == 1]

# run smoothclust
spe <- smoothclust(spe)

# see vignette for extended example including downstream analyses

}
